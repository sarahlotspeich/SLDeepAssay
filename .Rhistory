library(devtools)
document
document()
rm(list = ls())
library(dplyr)
library(dplyr)
library(ggplot2)
library(dplyr)
library(ggplot2)
library(devtools)
library(numDeriv)
library(pbapply)
library(emdbook)
library(ggbreak)
devtools::install_github("sarahlotspeich/SLDeepAssay")
library(SLDeepAssay)
# fixed parameters
set.seed(1)
u. <- c(0.025, 0.1, 0.5, 2.5)    # dilution levels
D. <- length(u.)                 # number of dilution levels
M. <- rep(100, 4)                # number of replicate wells
q. <- c(0, 0, 1, 0)              # proportion deep-sequenced
n. <- 7                          # number of DVLs
Tau. <- 1.19                     # IUPM
tau. <- rep(1/n., n.)            # DVL-specific IUPMs
n.rep <- 500                     # number of replications per setting
# parameters that vary by simulation setting
k. <- c(Inf, 5, 1, 0.25)
sim.in <- expand.grid("k" = k., "seed" = 1:n.rep) %>%
as.data.frame()
i =1
M = M.
tau = tau.
q = q.
u = u.
k = sim.in$k[i]
seed = sim.in$seed[i])
seed = sim.in$seed[i]
# set seed
if (!is.null(seed)) {
set.seed(seed)
}
# Create indicators of whether data need to be re-simulated
num_redo_all = 0 # Due to any DVL being detected in all wells or
num_redo_none = 0 # No DVL being detected in any wells
# Simulate single-dilution assay data
if (k == Inf) {
assay_summary = simulate_assay_md(
M = M,
tau = tau,
q = q,
u = u,
remove_undetected = remove_undetected)
} else {
assay_summary = negbin_simulate_assay_md(
M = M,
tau = tau,
q = q,
u = u,
k = k,
remove_undetected = remove_undetected)
}
remove_undetected = TRUE
# set seed
if (!is.null(seed)) {
set.seed(seed)
}
# Create indicators of whether data need to be re-simulated
num_redo_all = 0 # Due to any DVL being detected in all wells or
num_redo_none = 0 # No DVL being detected in any wells
# Simulate single-dilution assay data
if (k == Inf) {
assay_summary = simulate_assay_md(
M = M,
tau = tau,
q = q,
u = u,
remove_undetected = remove_undetected)
} else {
assay_summary = negbin_simulate_assay_md(
M = M,
tau = tau,
q = q,
u = u,
k = k,
remove_undetected = remove_undetected)
}
# Check for need to re-simulate
max_p24_neg = tryCatch(expr = max(assay_summary$M - assay_summary$MP),
error = function(e) 0)
min_DVL_neg = tryCatch(expr = min(colSums(assay_summary$m - assay_summary[, grepl("Y", colnames(assay_summary))])),
error = function(e) 0)
while ((max_p24_neg == 0 & min_DVL_neg == 0) | is.null(assay_summary)) {
if (is.null(assay)) {
num_redo_none = num_redo_none + 1
} else {
num_redo_all = num_redo_all + 1
}
# Re-simulate single-dilution assay data
# Simulate single-dilution assay data
if (k == Inf) {
assay_summary = simulate_assay_md(
M = M,
tau = tau,
q = q,
u = u,
remove_undetected = remove_undetected)
} else {
assay_summary = negbin_simulate_assay_md(
M = M,
tau = tau,
q = q,
u = u,
k = k,
remove_undetected = remove_undetected)
}
max_p24_neg = tryCatch(expr = max(assay_summary$M - assay_summary$MP),
error = function(e) 0)
min_DVL_neg = tryCatch(expr = min(colSums(assay_summary$m - assay_summary[, grepl("Y", colnames(assay_summary))])),
error = function(e) 0)
}
# analyze assay
res <- fit_lrt(assay_summary = assay_summary)
# analyze assay
res <- fit_SLDeepAssay_md_lrt(assay_summary = assay_summary)
# analyze assay
res <- lrt_SLDeepAssay_md(assay_summary = assay_summary)
}
}
lrt_SLDeepAssay_md = function(assay = NULL,
u = NULL,
assay_summary,
corrected = NULL,
maxit = 1E6,
lb = 1E-6,
ub = Inf) {
# For each dilution level, compute summary data
if (!is.null(assay)) {
assay_summary = vapply(X = 1:D, FUN.VALUE = numeric(7 + n),
FUN = function(d) {
M = ncol(assay[[d]])
n = nrow(assay[[d]])
MN = sum(colSums(assay[[d]]) == 0, na.rm = TRUE)
MP = M - MN
m = MP - sum(is.na(colSums(assay[[d]])))
q = ifelse(MP == 0, 0, m / MP)
Y = rowSums(assay[[d]], na.rm = TRUE)
return((c("u" = u[d], "M" = M, "n" = n,
"MN" = MN, "MP" = MP, "m" = m, "q" = q, "Y" = Y)))
})
assay_summary = as.data.frame(t(assay_summary))
}
# Indicator for whether bias correction should be computed:
# user specified value if provided, else yes if n <= 40
corrected = ifelse(test = is.null(corrected),
yes = assay_summary$n[1] <= 40,
no = corrected)
# Fit MLE under Poisson model
opt_pois = optim(par = rep(0, assay_summary$n[1]),
fn = function(t)
loglik_md(tau = t, assay_summary = assay_summary),
gr = function(t)
gloglik_md(tau = t, assay_summary = assay_summary),
method = "L-BFGS-B",
control = list(maxit = maxit),
lower = rep(lb, assay_summary$n[1]),
upper = rep(ub, assay_summary$n[1]),
hessian = F)
# Fit MLE under NegBin model
opt_negbin = optim(
par = c(rep(0, assay_summary$n[1]), 10),
fn = function(tk) negbin_loglik_md(tau = head(tk, assay_summary$n[1]),
k = tail(tk, 1),
assay_summary = assay_summary),
gr = function(tk) negbin_gloglik_md(tau = head(tk, assay_summary$n[1]),
k = tail(tk, 1),
assay_summary = assay_summary),
method = "L-BFGS-B",
control = list(maxit = maxit),
lower = rep(lb, assay_summary$n[1] + 1),
upper = rep(ub, assay_summary$n[1] + 1),
hessian = T)
# log-likelihood values
loglik_pois = -1 * opt_pois$value
loglik_negbin = -1 * opt_negbin$value
# likelihood ratio statistic
lrt_stat = max(-2 * (loglik_pois - loglik_negbin), 0)
# Poisson model parameter estimates
tau_hat = opt_pois$par
Tau_hat = sum(tau_hat)
# negative binomial model parameter estimates
if (loglik_negbin < loglik_pois) {
tau_hat_negbin = head(opt_negbin$par, assay_summary$n[1])
Tau_hat_negbin = sum(tau_hat_negbin)
k_hat_negbin = tail(opt_negbin$par, 1)
} else {
Tau_hat_negbin = Tau_hat
k_hat_negbin = Inf
}
# Fisher information matrix
I <- fisher_md(tau = tau_hat,
M = assay_summary$M,
q = assay_summary$q,
u = assay_summary$u)
# inverse of fisher information
cov <- solve(I)
### variance estimate 4
se <- sqrt(sum(cov))
### confidence interval
ci = exp(c(log(Tau_hat) + c(-1, 1) * (qnorm(0.975) * se / Tau_hat)))
# For large n, do not compute bias correction unless user overrides
if (corrected == F) {
Tau_hat_bc = NA
ci_bc = NA
} else {
### bias correction
tau_hat_bc <- BC_md(tau = tau_hat,
M = assay_summary$M,
q = assay_summary$q,
u = assay_summary$u)
# bias-corrected MLE for Tau
Tau_hat_bc <- sum(tau_hat_bc)
# bias corrected CI
ci_bc <- exp(c(log(Tau_hat_bc) + c(-1, 1) *
(qnorm(0.975) * se / Tau_hat_bc)))
}
return(list("mle" = Tau_hat,
"se" = se,
"ci" = ci,
"mle_bc" = Tau_hat_bc,
"ci_bc" = ci_bc,
"mle_negbin" = Tau_hat_negbin,
"mle_k" = k_hat_negbin,
"lrt_stat" = lrt_stat))
}
# analyze assay
res <- lrt_SLDeepAssay_md(assay_summary = assay_summary)
num_redo_all
num_redo_none
res$k_hat_negbin
res$lrt_stat
lrt_one_sim = function(M, tau, q, u, k, seed = NULL, remove_undetected = TRUE) {
# set seed
if (!is.null(seed)) {
set.seed(seed)
}
# Create indicators of whether data need to be re-simulated
num_redo_all = 0 # Due to any DVL being detected in all wells or
num_redo_none = 0 # No DVL being detected in any wells
# Simulate single-dilution assay data
if (k == Inf) {
assay_summary = simulate_assay_md(
M = M,
tau = tau,
q = q,
u = u,
remove_undetected = remove_undetected)
} else {
assay_summary = negbin_simulate_assay_md(
M = M,
tau = tau,
q = q,
u = u,
k = k,
remove_undetected = remove_undetected)
}
# Check for need to re-simulate
max_p24_neg = tryCatch(expr = max(assay_summary$M - assay_summary$MP),
error = function(e) 0)
min_DVL_neg = tryCatch(expr = min(colSums(assay_summary$m - assay_summary[, grepl("Y", colnames(assay_summary))])),
error = function(e) 0)
while ((max_p24_neg == 0 & min_DVL_neg == 0) | is.null(assay_summary)) {
if (is.null(assay)) {
num_redo_none = num_redo_none + 1
} else {
num_redo_all = num_redo_all + 1
}
# Re-simulate single-dilution assay data
# Simulate single-dilution assay data
if (k == Inf) {
assay_summary = simulate_assay_md(
M = M,
tau = tau,
q = q,
u = u,
remove_undetected = remove_undetected)
} else {
assay_summary = negbin_simulate_assay_md(
M = M,
tau = tau,
q = q,
u = u,
k = k,
remove_undetected = remove_undetected)
}
max_p24_neg = tryCatch(expr = max(assay_summary$M - assay_summary$MP),
error = function(e) 0)
min_DVL_neg = tryCatch(expr = min(colSums(assay_summary$m - assay_summary[, grepl("Y", colnames(assay_summary))])),
error = function(e) 0)
}
# analyze assay
res <- lrt_SLDeepAssay_md(assay_summary = assay_summary)
# Construct list to return
return(c("num_redo_all" = num_redo_all,
"num_redo_none" = num_redo_none,
"mle_pois" = res$mle,
"mle_negbin" = res$mle_negbin,
"mle_k" = res$mle_k,
"lrt_stat" = res$lrt_stat))
}
setwd("C:/Users/Brian Richardson/OneDrive - University of North Carolina at Chapel Hill/Desktop/CFAR/Projects in Progress/IUPM/SLDeepAssay")
document()
